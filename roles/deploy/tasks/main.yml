---
- name: Update packages
  yum:
    name: "*"
    state: latest

- name: Install dependencies
  yum:
    name: [git, wget, tar]
    state: present

- name: Create git group
  group:
    name: git
    system: yes

- name: Create git user (following official guide)
  user:
    name: git
    system: yes
    shell: /bin/bash
    comment: "Git Version Control"
    group: git
    home: /home/git
    create_home: yes

- name: Create required directory structure
  file:
    path: "{{ item.path }}"
    state: directory
    owner: "{{ item.owner }}"
    group: "{{ item.group }}"
    mode: "{{ item.mode }}"
  loop:
    - { path: "/var/lib/gitea", owner: "git", group: "git", mode: "0750" }
    - {
        path: "/var/lib/gitea/custom",
        owner: "git",
        group: "git",
        mode: "0750",
      }
    - { path: "/var/lib/gitea/data", owner: "git", group: "git", mode: "0750" }
    - { path: "/var/lib/gitea/log", owner: "git", group: "git", mode: "0750" }
    - {
        path: "/var/lib/gitea/data/gitea-repositories",
        owner: "git",
        group: "git",
        mode: "0750",
      }
    - { path: "/etc/gitea", owner: "root", group: "git", mode: "0770" }

- name: Generate Gitea secret key
  command: /usr/local/bin/gitea generate secret SECRET_KEY
  register: gitea_secret_key_output
  changed_when: false
  ignore_errors: yes

- name: Generate Gitea internal token
  command: /usr/local/bin/gitea generate secret INTERNAL_TOKEN
  register: gitea_internal_token_output
  changed_when: false
  ignore_errors: yes

- name: Set secret key fact
  set_fact:
    gitea_secret_key: "{{ gitea_secret_key_output.stdout if gitea_secret_key_output.rc == 0 else 'CHANGE_ME_SECRET_KEY_' + ansible_date_time.epoch }}"
    gitea_internal_token: "{{ gitea_internal_token_output.stdout if gitea_internal_token_output.rc == 0 else 'CHANGE_ME_INTERNAL_TOKEN_' + ansible_date_time.epoch }}"

- name: Wait for RDS MySQL to be available
  wait_for:
    host: "{{ rds_address }}"
    port: 3306
    timeout: 60
    delay: 5
  when: rds_address is defined

- name: Deploy Gitea configuration (app.ini) with RDS MySQL
  template:
    src: app.ini.j2
    dest: /etc/gitea/app.ini
    owner: root
    group: git
    mode: "0640"

- name: Download Gitea binary (v{{ gitea_version }})
  get_url:
    url: https://dl.gitea.com/gitea/{{ gitea_version }}/gitea-{{ gitea_version }}-linux-amd64
    dest: /usr/local/bin/gitea
    mode: "0755"
    owner: root
    group: root

- name: Create Gitea service
  template:
    src: gitea.service
    dest: /etc/systemd/system/gitea.service

- name: Set GITEA_WORK_DIR environment
  lineinfile:
    path: /etc/environment
    line: "GITEA_WORK_DIR=/var/lib/gitea"
    create: yes

- name: Enable and start Gitea service (systemd)
  systemd:
    name: gitea
    enabled: yes
    state: started
    daemon_reload: yes

- name: Wait for Gitea to start
  wait_for:
    port: 3000
    host: localhost
    delay: 5
    timeout: 60

- name: Verify Gitea service status
  systemd:
    name: gitea
  register: gitea_service_status

- name: Verify Gitea service availability
  uri:
    url: "http://localhost:3000"
    method: GET
    status_code: 200
    timeout: 10
  retries: 5
  delay: 10
  register: gitea_health

- name: Display deployment status summary
  debug:
    msg: |
      infraGitea Deployment Complete!
      - Gitea Service (3000): {{ 'HEALTHY' if gitea_health.status == 200 else 'STARTING' }}
      - SystemD Service: {{ gitea_service_status.status.ActiveState }}
      - Version: {{ gitea_version }}
      - User: git (system user)
      - Data Directory: /var/lib/gitea
      - Config: /etc/gitea/app.ini
      - Database: MySQL (RDS)
      - RDS Endpoint: {{ rds_endpoint }}
      - Database Name: {{ mysql_dbname }}
      - Service Management:
        * sudo systemctl status gitea
        * sudo systemctl restart gitea
        * sudo systemctl stop gitea
      - Access Gitea at: http://{{ ansible_default_ipv4.address }}:3000

      Gitea is READY TO USE!
      - Database is pre-configured with RDS MySQL
      - No manual setup required
      - Access via Load Balancer for production use
      
      Service runs automatically at boot via systemd
